## 16 | HTTP 헤더2 - 캐시와 조건부 요청

[1. 캐시 기본 동작](#캐시-기본-동작) <br>
[2. 검증 헤더와 조건부 요청 - 1](#검증헤더와-조건부-요청---1) <br>
[3. 검증 헤더와 조건부 요청 - 2](#검증헤더와-조건부-요청---2) <br>
[4. 캐시와 조건부 요청 헤더](#캐시와-조건부-요청-헤더) <br>
[5. 프록시 캐시](#프록시캐시) <br>
[6. 캐시 무효화](#캐시-무효화) <br>

<br>

### 캐시 기본 동작
<hr>
데이터가 변경되지 않았음에도 계속 네트워크로부터 데이터를 받는 것은 비효율적이다. 캐시를 활용하면 이러한 점을 해결할 수 있다.

<br>

#### 캐시가 없을 때

- 데이터 변경하지 않아도 네트워크를 통해 계속 데이터 다운로드
- 인터넷 네트워크는 상대적으로 PC의 메모리, 하드디스크에 비해 매우 느리고 비쌈
- 브라우저 로딩 속도 느림 

<br>

#### 캐시 적용

- 서버의 응답결과를 **캐시가 유효한 시간동안 브라우저 캐시에 저장**
- 클라이언트는 요청의 결과를 네트워크가 아닌 캐시로 받음
- 네트워크 사용량 및 브라우저 로딩속도가 개선
- 캐시 유효시간 초과된 경우라면 서버와 캐시의 내용이 다를 수 있기 때문에 서버로 부터 응답을 새로 받아야함
    => 이때 네트워크 다운로드 발생
- 캐시 만료되었다고 바로 삭제되진 않음 (for 캐시 재사용)

<br>

### 검증헤더와 조건부 요청 - 1
<hr>

캐시 유효시간이 초과되어 서버에 다시 요청하면 두가지 상황 발생

**1. 서버에서 기존 데이터 변경** <br>
**2. 서버에서 기존 데이터 변경하지 않음**

<br>

서버에서 클라이언트로 데이터를 전송하는 대신 저장해뒀던 캐시를 재사용할 수 있다.
단 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요한데, 이때 검증 헤더를 사용한다.

<br>

#### 검증헤더를 이용하는 과정

1. 서버는 데이터가 최종적으로 수정된 시간을 `Last-Modified`에 기록해 헤더에 담아 보낸다. 

2. 클라이언트는 이를 저장해두었다가 요청헤더에 조건부 요청 헤더인 `if-modified-since`에 최종수정일을 담아 보낸다.

3. 서버가 해당 데이터에 대한 최종 수정일을 비교해 데이터 수정여부를 검증한다.

4. 데이터가 수정되지 않았다면 `304 Not Modified`와 HTTP 바디를 비워 보낸다. (헤더만 전송)

5. 클라이언트는 브라우저에 저장되어있던 캐시의 메타 정보를 갱신해 그대로 재사용하므로 네트워크 부하를 줄일 수 있다.


<br>

### 검증헤더와 조건부 요청 - 2
<hr>

#### 검증헤더 

검증헤더는 **캐시데이터와 서버데이터가 같은지 검증하는 데이터**로 `Last-Modified`와 `ETag`가 있다. 

If-Modified-Since는 Last-Modified와 같이 사용하며 If-None-Match는 Etag와 같이 사용한다.

If-Modified-Since 이후에 데이터가 수정이 안되었다면 `304 Not Modified`와 함께 헤더만 전송한다. 데이터가 수정되었다면 `200 OK`와 함께 헤더와 바디를 전송한다.

<br>
 

#### Last-Modified, If-Modified-Since의 단점

- 1초 미만 단위로 캐시조정이 불가능
- 날짜 기반의 로직을 사용
- 데이터가 동일하더라도 날짜값이 다른 경우에도 헤더와 바디 전송

 

#### ETag, If-None-Match

- 캐시용 데이터에 임의의 고유한 버전 이름을 부여
- 데이터가 변경되었을 때 이름을 변경
- 서버는 클라이언트의 ETag의 해시 값을 비교해 데이터 변경 여부를 체크해 캐시 변경여부 확인 
    - 같으면 유지, 다르면 다시 받기
- 캐시 제어 로직을 서버에서 완전히 관리

 
<br>

### 캐시와 조건부 요청 헤더
<hr>

#### 캐시 제어 헤더 종류
 
- Cache-Control
    - 캐시 지시어(directives)
    - `Cache-Control: max-age`
        - 캐시 유효 시간, 초 단위
    - `Cache-Control:no-cache`
        - 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용
    - `Cache-Control:no-store`
        - 데이터에 민감한 정보를 포함하기 때문에 저장하면 안되는 데이터
        - 메모리에서만 사용하고 최대한 빨리 삭제
- Pragma
    - HTTP1.0의 하위호환에 사용되는 캐시제어 헤더 
    - 현재는 거의 사용 X
- Expires
    - 캐시만료일 지정
    - 현재는 더 유연한 `Cache-Control:max-age`를 권장
    - Cache-Control:max-age와 Expires가 함께 사용되는 경우 Expires는 무시
    - ex) `expires: Mon, 01 Jan 1990 00:00:00 GMT``

<br>

### 프록시캐시
<hr>

- 원(origin) 서버
    - **웹브라우저에서 요청이 최종적으로 도착하는 서버**
    - 원서버와 클라이언트 간의 거리가 멀어지면 서버의 응답이 도착하는 시간이 지연될 수 있음
        - 웹브라우저와 원 서버 사이에 프록시 캐시 서버를 둠 <br>
         => 웹브라우저의 요청이 프록시 서버를 거치기 때문에 **캐시 서버상에서 응답할 수 있는 요청이라면 더 빠르게 받아볼 수 있음**


<br>

#### 프록시 캐시 도입

- public 캐시 : 프록시 캐시 서버에 저장된 캐시는 공용으로 사용되는 캐시
- private 캐시 : 웹브라우저(로컬)에 저장된 캐시
    => 캐시 지시어를 통해 구분

<br> 

#### 캐시 지시어

1. Cache-Control:public
    - public 캐시에 응답 저장 가능
<br>

2. Cache-Control:private
    - 해당 사용자만을 위한 응답이므로 private 캐시에 저장 (기본값)
<br>

3. Cache-Control:s-maxage
    - 프록시 캐시에만 적용되는 max-age
<br>

4. Age : 60(HTTP 헤더)
    - origin 서버에서 응답 후 프록시 캐시 내에 머문 시간(초 단위)

<br>

### 캐시 무효화
<hr>

웹 브라우저가 자주 사용하는 페이지를 임의로 캐시를 적용할 수 있다. 예를 들어 get 요청인 경우 임의로 웹브라우저들이 캐시를 해버린다.
그렇기에 캐시 되지 말아야할 페이지가 있다면 캐시 무효화 응답을 넣어줘야 한다. 

캐시무효화를 위해 필요한 설정은 다음과 같다.

<br>

1. Cache-Control:no-cache
    - 데이터는 캐시해도 되지만, 항상 **원 서버**에서 검증하고 사용

2. Cache-Control:no-store
    - 데이터에 민감한 정보가 있으므로 저장하면 안됨 
    - 메모리에서 사용하고 최대한 빨리 삭제

3. Cache-Control:must-revalidate
    - 캐시 만료 후 최초 조회시 **원 서버에 검증**
    - 원 서버 접근 실패시 반드시 오류가 발생해야함(504 Gateway Timeout)

4. Pragma:no-cache
    - Cache-Control 이 사용되지 않는 과거 브라우저(HTTP 1.0)에서 요청이 들어오는 경우를 대비
 
<br>

**※ no-cache와 must-revalidate를 함께 사용하는 이유**
<br>

`no-cache`의 경우 프록시 캐시 서버 설정에 따라 정상 응답을 해줄 수 있기에 유효시간이 지난 캐시를 사용하면 안되는 경우에도 사용할 수 있다.
이를 방지고자 `no-cache`와 `must-revalidate`를 조합하여 사용한다.
